**real-world architecture pattern** that’s very common in production ECS environments using **Spinnaker + Terraform**. Let’s walk through a **recommended approach** for introducing **Blue/Green (Red/Black)** deployment **without rewriting your existing Terraform setup**, but extending it safely.

---

## 🧭 Goal

You already have:

* Terraform creating ECS Cluster, Service, ALB, Target Groups, IAM roles, etc.
* Spinnaker configured to deploy ECS Tasks (Red/Black).
* Dynatrace integrated via Secrets Manager.

You want:

* Terraform structure that supports Spinnaker’s blue/green (a.k.a. red/black) rollout strategy cleanly.
* Automated pipeline promotion and rollback support.
* Minimal Terraform drift.

---

## ⚙️ 1. **Terraform – Infrastructure as Baseline**

Terraform should manage **infrastructure scaffolding** — not the deployed ECS task revisions.

### ✅ Terraform’s responsibilities:

* Create:

  * ECS Cluster
  * ALB + Listeners + Rules
  * Target Groups (`blue`, `green`)
  * ECS Service definition (without pinned task)
  * IAM roles, CloudWatch, Secrets, etc.
* Output key values (for Spinnaker):

  * ALB ARN
  * Target group ARNs
  * Cluster name
  * Service name

Terraform **should not**:

* Pin `task_definition` to a specific revision.
* Manage container image version directly.

This allows Spinnaker to handle revisions dynamically.

---

## 🧩 2. **Terraform Setup Example**

### Example ECS Service setup (Terraform)

```hcl
resource "aws_lb_target_group" "blue" {
  name     = "myapp-blue-tg"
  port     = 80
  protocol = "HTTP"
  vpc_id   = var.vpc_id
  health_check {
    path = "/health"
  }
}

resource "aws_lb_target_group" "green" {
  name     = "myapp-green-tg"
  port     = 80
  protocol = "HTTP"
  vpc_id   = var.vpc_id
  health_check {
    path = "/health"
  }
}

resource "aws_lb_listener_rule" "blue_rule" {
  listener_arn = aws_lb_listener.http.arn
  priority     = 10

  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.blue.arn
  }

  condition {
    host_header {
      values = ["myapp.example.com"]
    }
  }
}

output "ecs_service_name" {
  value = aws_ecs_service.app.name
}

output "target_group_blue" {
  value = aws_lb_target_group.blue.arn
}

output "target_group_green" {
  value = aws_lb_target_group.green.arn
}
```

> 💡 These outputs are critical for Spinnaker to know where to route Blue vs Green tasks.

---

## 🚀 3. **Spinnaker Red/Black (Blue/Green) Deployment Flow**

**Spinnaker pipeline** handles runtime logic:

1. **Trigger** – Artifact or image change (e.g., new ECR image or Git tag).
2. **Bake/Prepare Stage** – Build ECS task definition JSON.

   * Fetch secrets (e.g., Dynatrace tokens from AWS Secrets Manager).
   * Substitute image version.
3. **Deploy (ECS Red/Black)** stage:

   * Spinnaker registers a *new* task definition revision.
   * Launches “green” tasks in the secondary target group.
   * Health checks on green target group.
   * Shifts traffic from blue → green.
4. **Manual Judgment / Automated Verification (optional)**:

   * Integrate Dynatrace Quality Gate API to verify SLO metrics (error rate, latency, etc.).
5. **Disable/Delete Old (Blue) Service Tasks** after successful verification.
6. **Rollback** if health check fails → Spinnaker shifts back to blue TG automatically.

---

## 🔐 4. **Secret Management (Dynatrace Tokens)**

You’re already doing this perfectly — keep it this way.

Terraform:

```hcl
data "aws_secretsmanager_secret_version" "dynatrace" {
  secret_id = "dynatrace/tokens"
}

locals {
  dynatrace_api_token = jsondecode(data.aws_secretsmanager_secret_version.dynatrace.secret_string)["DT_API_TOKEN"]
}
```

ECS Task Definition (via Spinnaker):

```json
{
  "environment": [
    {
      "name": "DT_API_TOKEN",
      "valueFrom": {
        "secretKeyRef": {
          "name": "dynatrace-tokens",
          "key": "DT_API_TOKEN"
        }
      }
    }
  ]
}
```

---

## 🧠 5. **Terraform + Spinnaker Integration Strategy**

| Responsibility            | Terraform                   | Spinnaker                       |
| ------------------------- | --------------------------- | ------------------------------- |
| Networking, ALB, TGs      | ✅                           | ❌                               |
| ECS Cluster               | ✅                           | ❌                               |
| ECS Task Definitions      | ⚠️ Template only            | ✅ Manages revisions dynamically |
| Blue/Green Switching      | ❌                           | ✅ Red/Black strategy            |
| Secrets Management        | ✅ (via AWS Secrets Manager) | ✅ Injected securely             |
| Observability Integration | ✅                           | ✅ Health checks / rollback      |

---

## 🧰 6. **Best Practices**

* **Do not reapply Terraform** after every Spinnaker deploy — it should only manage infra, not task versions.
* Use **Terraform workspaces** for environment isolation (`dev`, `qa`, `prod`).
* **Output critical ALB/TG/cluster values** in Terraform, and feed them into Spinnaker pipeline parameters.
* Use **Spinnaker pipeline parameters** to dynamically reference the correct TGs or cluster.
* Configure **Automated Rollback** in Spinnaker → if new task fails health check, traffic reverts to blue.
* Keep **monitoring hooks (Dynatrace, CloudWatch alarms)** environment-specific.

---

## 📁 7. Folder Structure Example

```
infrastructure/
 ├── modules/
 │   └── ecs/
 │       ├── main.tf
 │       ├── variables.tf
 │       └── outputs.tf
 ├── envs/
 │   ├── dev/
 │   │   └── main.tf
 │   ├── qa/
 │   │   └── main.tf
 │   └── prod/
 │       └── main.tf
 ├── outputs.tf
 └── versions.tf

spinnaker/
 ├── pipelines/
 │   ├── ecs-bluegreen.json
 │   └── artifact-template.json
```

---

## 🧩 Example Output Connection

Terraform → Spinnaker via Pipeline Parameters:

```json
{
  "type": "parameter",
  "name": "targetGroupBlueArn",
  "default": "${terraform-output.target_group_blue}"
}
```

---

Would you like me to show you an example of the **Spinnaker ECS Red/Black pipeline JSON definition** that references Terraform outputs and manages traffic shifting between blue and green target groups?
That would complete the full flow.
